
from Malware2ATTCK import *

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
trained_transR_model = torch.load("models\\transR\\transR_model\\trained_model.pkl")
with open("kg_data\\kg_data.pickle",'rb') as f:
    kg_data = pickle.load(f)
    kg_data_np = np.array(kg_data)
    triples_factory = TriplesFactory.from_labeled_triples(kg_data_np)
model = GNN_KGmodel(input_dim=1536, hidden_dim=1024, num_classes=421, 
                    # num_relations= len(set([kg[1] for kg in kg_data])), 
                    trained_transR_model=trained_transR_model)
model.load_state_dict(torch.load("models\\Malware2ATT&CK\\model.bin"))
model.to(device)

with open('labels_vocab_win.txt','r') as f:
    vocab = f.read().splitlines()

test_dataset = GraphDataset("data\\test_dataset")
test_sampler = RandomSampler(test_dataset)
test_loader =  DataLoader(test_dataset,  batch_size=1, sampler=test_sampler, collate_fn=collate_fn, drop_last=False)

model.eval()
with torch.no_grad():
    y_true, y_pred = [], []
    for i, data in enumerate(test_loader):
        print(test_dataset.filenames[i])
        try:
            output = model(data.to(device))
        except:
            print(test_dataset.filenames[i])
            continue
        y_true_i = data.y.cpu().numpy()
        y_pred_i = torch.sigmoid(output).cpu().numpy()
        y_pred_i = np.concatenate(y_pred_i) > 0.5
        y_pred_i = np.where(y_pred_i > 0.5, 1, 0)
        y_label = []
        for j, y in np.ndenumerate(y_pred_i):
            if y:
                y_label.append(vocab[j[0]])
        print(y_label)

        torch.cuda.empty_cache()
        print('*'*20)
f.close()